<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Udns_name (udns.Udns_name)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">udns</a> &#x00BB; Udns_name</nav><h1>Module <code>Udns_name</code></h1></header><dl><dt class="spec module" id="module-IntMap"><a href="#module-IntMap" class="anchor"></a><code><span class="keyword">module </span>IntMap : Stdlib.Map.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-IntMap">IntMap</a>.key<span class="keyword"> = </span>int</code></dt><dd><p>The module of an integer map</p></dd></dl><dl><dt class="spec type" id="type-err"><a href="#type-err" class="anchor"></a><code><span class="keyword">type </span>err</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-err.Partial" class="anchored"><td class="def constructor"><a href="#type-err.Partial" class="anchor"></a><code><span class="keyword">| </span></code><code>`Partial</code></td></tr><tr id="type-err.BadOffset" class="anchored"><td class="def constructor"><a href="#type-err.BadOffset" class="anchor"></a><code><span class="keyword">| </span></code><code>`BadOffset<span class="keyword"> of </span>int</code></td></tr><tr id="type-err.BadTag" class="anchored"><td class="def constructor"><a href="#type-err.BadTag" class="anchor"></a><code><span class="keyword">| </span></code><code>`BadTag<span class="keyword"> of </span>int</code></td></tr><tr id="type-err.BadContent" class="anchored"><td class="def constructor"><a href="#type-err.BadContent" class="anchor"></a><code><span class="keyword">| </span></code><code>`BadContent<span class="keyword"> of </span>string</code></td></tr><tr id="type-err.TooLong" class="anchored"><td class="def constructor"><a href="#type-err.TooLong" class="anchor"></a><code><span class="keyword">| </span></code><code>`TooLong</code></td></tr></table><code> ]</code></dt><dd><p>Errors while decoding a domain name.</p></dd></dl><dl><dt class="spec value" id="val-pp_err"><a href="#val-pp_err" class="anchor"></a><code><span class="keyword">val </span>pp_err : <a href="index.html#type-err">err</a> Fmt.t</code></dt><dd><p><code>pp ppf error</code> pretty prints the <code>error</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-decode"><a href="#val-decode" class="anchor"></a><code><span class="keyword">val </span>decode : ?&#8288;hostname:bool <span>&#45;&gt;</span> (Domain_name.t<span class="keyword"> * </span>int) <a href="index.html#module-IntMap">IntMap</a>.t <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> (Domain_name.t<span class="keyword"> * </span>(Domain_name.t<span class="keyword"> * </span>int) <a href="index.html#module-IntMap">IntMap</a>.t<span class="keyword"> * </span>int, [&gt; <a href="index.html#type-err">err</a> ]) Stdlib.result</code></dt><dd><p><code>decode ~hostname map buf off</code> decodes a domain name from <code>buf</code> at position <code>off</code>. If <code>hostname</code> is provided and <code>true</code> (the default), the domain name is additionally checked for being a hostname using <code>is_hostname</code>.</p><p>RFC 1035 specifies label compression: a domain name may either end with the root label or a pointer (byte offset from the beginning of the frame) to a domain name. To support decompression, a <code>map</code> between offsets and domain names and length is passed around, and the absolute <code>offset</code> in the frame. The return value is either a decoded and decompressed domain name, an extended map, and the consumed bytes (as offset into the buffer), or an error.</p></dd></dl><dl><dt class="spec value" id="val-encode"><a href="#val-encode" class="anchor"></a><code><span class="keyword">val </span>encode : ?&#8288;compress:bool <span>&#45;&gt;</span> int Domain_name.Map.t <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> int <span>&#45;&gt;</span> Domain_name.t <span>&#45;&gt;</span> int Domain_name.Map.t<span class="keyword"> * </span>int</code></dt><dd><p><code>encode ~compress map buf off t</code> encodes <code>t</code> into <code>buf</code>, extending the <code>map</code>. If <code>compress</code> is <code>true</code> (the default), and a (sub)domain name of <code>t</code> is in <code>map</code>, a pointer is inserted instead of the full domain name.</p><p>NB: DNS (especially RFC 3597) mentions that pointers should only point to domain names in resource data which are well known (which means specified in RFC 1035). To achieve this, the caller of <code>encode</code> if inside of other resource data fields needs to discard the returned <code>map</code>, and continue to use the provided <code>map</code>. There should be no reason to use <code>~compress:false</code> (esp. these resource data fields which are _not_ well known may still contain pointers to well known ones.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the provided <code>buf</code> is too small.</p></dd></dl></dd></dl></div></body></html>